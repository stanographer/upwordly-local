{"ast":null,"code":"/* This contains the textarea binding for ShareDB. This binding is really\n * simple, and a bit slow on big texuments (Its O(N). However, it requires no\n * changes to the DOM and no heavy libraries like ace. It works for any kind of\n * text input field.\n *\n * You probably want to use this binding for small fields on forms and such.\n * For code editors or rich text editors or whatever, I recommend something\n * heavier.\n */\n\n/* applyChange creates the edits to convert oldVal -> newVal.\n *\n * This function should be called every time the text element is changed.\n * Because changes are always localised, the diffing is quite easy. We simply\n * scan in from the start and scan in from the end to isolate the edited range,\n * then delete everything that was removed & add everything that was added.\n * This wouldn't work for complex changes, but this function should be called\n * on keystroke - so the edits will mostly just be single character changes.\n * Sometimes they'll paste text over other text, but even then the diff\n * generated by this algorithm is correct.\n *\n * This algorithm is O(N). I suspect you could speed it up somehow using regular expressions.\n */\n// Attach a textarea to a document's editing context.\n// The context is optional, and will be created from the document if its not\n// specified.\nexport var attachTextarea = function attachTextarea(elem, doc) {\n  elem.value = doc.data; // The current value of the element's text is stored so we can quickly check\n  // if its been changed in the event handlers. This is mostly for browsers on\n  // windows, where the content contains \\r\\n newlines. applyChange() is only\n  // called after the \\r\\n newlines are converted, and that check is quite\n  // slow. So we also cache the string before conversion so we can do a quick\n  // check in case the conversion isn't needed.\n\n  var prevValue;\n  var newSelection = [];\n  /*\n   ADD-IN\n   Enabling the tab key on the textarea.\n   */\n\n  elem.onkeydown = function (e) {\n    // Tab was pressed\n    if (e.key === 'Tab') {\n      // Prevent normal behavior of switching element focus.\n      e.preventDefault(); // Get caret position/selection\n\n      var val = elem.value,\n          start = elem.selectionStart,\n          end = elem.selectionEnd; // Set textarea value to: text before caret + tab + text after caret\n\n      elem.value = val.substring(0, start) + '\\t' + val.substring(end); // Put caret at right position again\n\n      elem.selectionStart = elem.selectionEnd = start + 1; // Prevent the focus lose\n\n      return false;\n    }\n  };\n\n  var applyChange = function applyChange(doc, oldVal, newVal) {\n    // Strings are immutable and have reference equality. I think this tests is O(1), so its worth doing.\n    if (oldVal === newVal) {\n      return;\n    }\n\n    var commonStart = 0;\n\n    while (oldVal.charAt(commonStart) === newVal.charAt(commonStart)) {\n      commonStart++;\n    }\n\n    var commonEnd = 0;\n\n    while (oldVal.charAt(oldVal.length - 1 - commonEnd) === newVal.charAt(newVal.length - 1 - commonEnd) && commonEnd + commonStart < oldVal.length && commonEnd + commonStart < newVal.length) {\n      commonEnd++;\n    }\n\n    if (oldVal.length !== commonStart + commonEnd) {\n      var op = [commonStart, '', {\n        d: oldVal.length - commonStart - commonEnd\n      }];\n      doc.submitOp(op);\n    }\n\n    if (newVal.length !== commonStart + commonEnd) {\n      doc.submitOp([commonStart, newVal.slice(commonStart, newVal.length - commonEnd)]);\n    }\n  };\n  /* Replace the content of the text area with newText, and transform the\n   current cursor by the specified function. */\n\n\n  var replaceText = function replaceText(newText, transformCursor) {\n    if (transformCursor) {\n      newSelection = [transformCursor(elem.selectionStart), transformCursor(elem.selectionEnd)];\n    } // Fixate the window's scroll while we set the element's value. Otherwise\n    // the browser scrolls to the element.\n\n\n    var scrollTop = elem.scrollTop;\n    elem.value = newText;\n    prevValue = elem.value; // Not done on one line so the browser can do newline conversion.\n\n    if (elem.scrollTop !== scrollTop) {\n      elem.scrollTop = scrollTop;\n    } // Setting the selection moves the cursor. We'll just have to let your\n    // cursor drift if the element isn't active, though usually users don't\n    // care.\n\n\n    if (newSelection && window.document.activeElement === elem) {\n      elem.selectionStart = newSelection[0];\n      elem.selectionEnd = newSelection[1];\n    }\n  };\n\n  replaceText(doc.data); // *** remote -> local changes\n\n  doc.on('op', function (op, localContext) {\n    if (localContext === true) {\n      return;\n    }\n\n    var prev = elem.value;\n    var newDoc = []; // Loop through the ops object.\n\n    for (var i = 0; i < op.length; i++) {\n      var component = op[i]; // Classifies the different components of the op.\n\n      switch (typeof component) {\n        // If it is a number, make it the index.\n        case 'number':\n          // fields.pos = component;\n          newDoc.push(prev.slice(0, component));\n          prev = prev.slice(component);\n          break;\n        // If it is a string, we know to insert it into the temp variable.\n\n        case 'string':\n          // fields.insertStr = component;\n          // onInsert(fields.pos, fields.insertStr);\n          newDoc.push(component);\n          break;\n        // If it is an object, we know it's a delete command.\n\n        case 'object':\n          prev = prev.slice(component.d); // fields.delNum = component.d;\n          // onRemove(fields.pos, fields.delNum);\n\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return setTimeout(function () {\n      replaceText(newDoc.join('') + prev);\n    }, 0);\n  }); // *** local -> remote changes\n  // This function generates operations from the changed content in the textarea.\n\n  var genOp = function genOp() {\n    // In a timeout so the browser has time to propagate the event's changes to the DOM.\n    setTimeout(function () {\n      if (elem.value !== prevValue) {\n        prevValue = elem.value;\n        applyChange(doc, doc.data, elem.value);\n      }\n    }, 0);\n  };\n\n  var eventNames = ['textInput', 'keydown', 'keyup', 'select', 'cut', 'paste'];\n\n  for (var i = 0; i < eventNames.length; i++) {\n    var e = eventNames[i];\n\n    if (elem.addEventListener) {\n      elem.addEventListener(e, genOp, false);\n    } else {\n      elem.attachEvent('on' + e, genOp);\n    }\n  }\n\n  doc.detach = function () {\n    for (var _i = 0; _i < eventNames.length; _i++) {\n      var _e = eventNames[_i];\n\n      if (elem.removeEventListener) {\n        elem.removeEventListener(_e, genOp, false);\n      } else {\n        elem.detachEvent('on' + _e, genOp);\n      }\n    }\n  };\n\n  return doc;\n};","map":{"version":3,"sources":["/Users/stanleysakai/Developer/upwordly-local/src/ShareDB/textarea.js"],"names":["attachTextarea","elem","doc","value","data","prevValue","newSelection","onkeydown","e","key","preventDefault","val","start","selectionStart","end","selectionEnd","substring","applyChange","oldVal","newVal","commonStart","charAt","commonEnd","length","op","d","submitOp","slice","replaceText","newText","transformCursor","scrollTop","window","document","activeElement","on","localContext","prev","newDoc","i","component","push","setTimeout","join","genOp","eventNames","addEventListener","attachEvent","detach","removeEventListener","detachEvent"],"mappings":"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","sourcesContent":["/* This contains the textarea binding for ShareDB. This binding is really\n * simple, and a bit slow on big texuments (Its O(N). However, it requires no\n * changes to the DOM and no heavy libraries like ace. It works for any kind of\n * text input field.\n *\n * You probably want to use this binding for small fields on forms and such.\n * For code editors or rich text editors or whatever, I recommend something\n * heavier.\n */\n\n/* applyChange creates the edits to convert oldVal -> newVal.\n *\n * This function should be called every time the text element is changed.\n * Because changes are always localised, the diffing is quite easy. We simply\n * scan in from the start and scan in from the end to isolate the edited range,\n * then delete everything that was removed & add everything that was added.\n * This wouldn't work for complex changes, but this function should be called\n * on keystroke - so the edits will mostly just be single character changes.\n * Sometimes they'll paste text over other text, but even then the diff\n * generated by this algorithm is correct.\n *\n * This algorithm is O(N). I suspect you could speed it up somehow using regular expressions.\n */\n\n// Attach a textarea to a document's editing context.\n// The context is optional, and will be created from the document if its not\n// specified.\nexport const attachTextarea = function (elem, doc) {\n  elem.value = doc.data;\n\n  // The current value of the element's text is stored so we can quickly check\n  // if its been changed in the event handlers. This is mostly for browsers on\n  // windows, where the content contains \\r\\n newlines. applyChange() is only\n  // called after the \\r\\n newlines are converted, and that check is quite\n  // slow. So we also cache the string before conversion so we can do a quick\n  // check in case the conversion isn't needed.\n\n  let prevValue;\n  let newSelection = [];\n\n  /*\n   ADD-IN\n   Enabling the tab key on the textarea.\n   */\n\n  elem.onkeydown = e => {\n    // Tab was pressed\n    if (e.key === 'Tab') {\n\n      // Prevent normal behavior of switching element focus.\n      e.preventDefault();\n\n      // Get caret position/selection\n      let val = elem.value,\n          start = elem.selectionStart,\n          end = elem.selectionEnd;\n\n      // Set textarea value to: text before caret + tab + text after caret\n      elem.value = val.substring(0, start) + '\\t' + val.substring(end);\n\n      // Put caret at right position again\n      elem.selectionStart = elem.selectionEnd = start + 1;\n\n      // Prevent the focus lose\n      return false;\n    }\n  };\n\nconst applyChange = function (doc, oldVal, newVal) {\n\n  // Strings are immutable and have reference equality. I think this tests is O(1), so its worth doing.\n  if (oldVal === newVal) {\n    return;\n  }\n\n  let commonStart = 0;\n\n  while (oldVal.charAt(commonStart) === newVal.charAt(commonStart)) {\n    commonStart++;\n  }\n\n  let commonEnd = 0;\n\n  while (oldVal.charAt(oldVal.length - 1 - commonEnd) === newVal.charAt(newVal.length - 1 - commonEnd) &&\n  commonEnd + commonStart < oldVal.length && commonEnd + commonStart < newVal.length) {\n    commonEnd++;\n  }\n\n  if (oldVal.length !== commonStart + commonEnd) {\n    let op = [\n      commonStart,\n      '',\n      {d: oldVal.length - commonStart - commonEnd}\n    ];\n    doc.submitOp(op);\n  }\n\n  if (newVal.length !== commonStart + commonEnd) {\n    doc.submitOp([commonStart, newVal.slice(commonStart, newVal.length - commonEnd)]);\n  }\n};\n\n  /* Replace the content of the text area with newText, and transform the\n   current cursor by the specified function. */\n\n  const replaceText = function (newText, transformCursor) {\n    if (transformCursor) {\n      newSelection = [transformCursor(elem.selectionStart), transformCursor(elem.selectionEnd)];\n    }\n\n    // Fixate the window's scroll while we set the element's value. Otherwise\n    // the browser scrolls to the element.\n    let scrollTop = elem.scrollTop;\n    elem.value = newText;\n    prevValue = elem.value; // Not done on one line so the browser can do newline conversion.\n    if (elem.scrollTop !== scrollTop) {\n      elem.scrollTop = scrollTop;\n    }\n\n    // Setting the selection moves the cursor. We'll just have to let your\n    // cursor drift if the element isn't active, though usually users don't\n    // care.\n    if (newSelection && window.document.activeElement === elem) {\n      elem.selectionStart = newSelection[0];\n      elem.selectionEnd = newSelection[1];\n    }\n  };\n\n  replaceText(doc.data);\n\n  // *** remote -> local changes\n\n  doc.on('op', function (op, localContext) {\n    if (localContext === true) {\n      return;\n    }\n\n    let prev = elem.value;\n    const newDoc = [];\n\n    // Loop through the ops object.\n    for (let i = 0; i < op.length; i++) {\n      let component = op[i];\n      // Classifies the different components of the op.\n      switch (typeof component) {\n          // If it is a number, make it the index.\n        case 'number':\n          // fields.pos = component;\n          newDoc.push(prev.slice(0, component));\n          prev = prev.slice(component);\n          break;\n          // If it is a string, we know to insert it into the temp variable.\n        case 'string':\n          // fields.insertStr = component;\n          // onInsert(fields.pos, fields.insertStr);\n          newDoc.push(component);\n          break;\n          // If it is an object, we know it's a delete command.\n        case 'object':\n          prev = prev.slice(component.d);\n          // fields.delNum = component.d;\n          // onRemove(fields.pos, fields.delNum);\n          break;\n        default:\n          break;\n      }\n    }\n    return setTimeout(() => {\n      replaceText(newDoc.join('') + prev);\n    }, 0);\n  });\n\n  // *** local -> remote changes\n\n  // This function generates operations from the changed content in the textarea.\n  const genOp = function () {\n\n    // In a timeout so the browser has time to propagate the event's changes to the DOM.\n    setTimeout(function () {\n      if (elem.value !== prevValue) {\n        prevValue = elem.value;\n        applyChange(doc, doc.data, elem.value);\n      }\n    }, 0);\n  };\n\n  const eventNames = [\n    'textInput',\n    'keydown',\n    'keyup',\n    'select',\n    'cut',\n    'paste'\n  ];\n\n  for (let i = 0; i < eventNames.length; i++) {\n    let e = eventNames[i];\n    if (elem.addEventListener) {\n      elem.addEventListener(e, genOp, false);\n    } else {\n      elem.attachEvent('on' + e, genOp);\n    }\n  }\n\n  doc.detach = function () {\n    for (let i = 0; i < eventNames.length; i++) {\n      let e = eventNames[i];\n      if (elem.removeEventListener) {\n        elem.removeEventListener(e, genOp, false);\n      } else {\n        elem.detachEvent('on' + e, genOp);\n      }\n    }\n  };\n\n  return doc;\n};"]},"metadata":{},"sourceType":"module"}