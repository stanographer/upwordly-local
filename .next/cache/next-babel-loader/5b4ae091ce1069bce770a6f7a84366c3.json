{"ast":null,"code":"/* This contains the textarea binding for ShareDB. This binding is really\n * simple, and a bit slow on big texuments (Its O(N). However, it requires no\n * changes to the DOM and no heavy libraries like ace. It works for any kind of\n * text input field.\n *\n * You probably want to use this binding for small fields on forms and such.\n * For code editors or rich text editors or whatever, I recommend something\n * heavier.\n */\n\n/* applyChange creates the edits to convert oldVal -> newVal.\n *\n * This function should be called every time the text element is changed.\n * Because changes are always localised, the diffing is quite easy. We simply\n * scan in from the start and scan in from the end to isolate the edited range,\n * then delete everything that was removed & add everything that was added.\n * This wouldn't work for complex changes, but this function should be called\n * on keystroke - so the edits will mostly just be single character changes.\n * Sometimes they'll paste text over other text, but even then the diff\n * generated by this algorithm is correct.\n *\n * This algorithm is O(N). I suspect you could speed it up somehow using regular expressions.\n */\n// Attach a textarea to a document's editing context.\n// The context is optional, and will be created from the document if its not\n// specified.\nexport var attachTextarea = function attachTextarea(elem, doc) {\n  elem.value = doc.data; // The current value of the element's text is stored so we can quickly check\n  // if its been changed in the event handlers. This is mostly for browsers on\n  // windows, where the content contains \\r\\n newlines. applyChange() is only\n  // called after the \\r\\n newlines are converted, and that check is quite\n  // slow. So we also cache the string before conversion so we can do a quick\n  // check in case the conversion isn't needed.\n\n  var prevValue;\n  var newSelection = [];\n  /*\n   ADD-IN\n   Enabling the tab key on the textarea.\n   */\n\n  elem.onkeydown = function (e) {\n    // Tab was pressed\n    if (e.key === 'Tab') {\n      // Prevent normal behavior of switching element focus.\n      e.preventDefault(); // Get caret position/selection\n\n      var val = elem.value,\n          start = elem.selectionStart,\n          end = elem.selectionEnd; // Set textarea value to: text before caret + tab + text after caret\n\n      elem.value = val.substring(0, start) + '\\t' + val.substring(end); // Put caret at right position again\n\n      elem.selectionStart = elem.selectionEnd = start + 1; // Prevent the focus lose\n\n      return false;\n    }\n  };\n\n  var applyChange = function applyChange(doc, oldVal, newVal) {\n    // Strings are immutable and have reference equality. I think this tests is O(1), so its worth doing.\n    if (oldVal === newVal) {\n      return;\n    }\n\n    var commonStart = 0;\n\n    while (oldVal.charAt(commonStart) === newVal.charAt(commonStart)) {\n      commonStart++;\n    }\n\n    var commonEnd = 0;\n\n    while (oldVal.charAt(oldVal.length - 1 - commonEnd) === newVal.charAt(newVal.length - 1 - commonEnd) && commonEnd + commonStart < oldVal.length && commonEnd + commonStart < newVal.length) {\n      commonEnd++;\n    }\n\n    if (oldVal.length !== commonStart + commonEnd) {\n      var op = [commonStart, '', {\n        d: oldVal.length - commonStart - commonEnd\n      }];\n      doc.submitOp(op);\n    }\n\n    if (newVal.length !== commonStart + commonEnd) {\n      doc.submitOp([commonStart, newVal.slice(commonStart, newVal.length - commonEnd)]);\n    }\n  };\n  /* Replace the content of the text area with newText, and transform the\n   current cursor by the specified function. */\n\n\n  var replaceText = function replaceText(newText, transformCursor) {\n    if (transformCursor) {\n      newSelection = [transformCursor(elem.selectionStart), transformCursor(elem.selectionEnd)];\n    } // Fixate the window's scroll while we set the element's value. Otherwise\n    // the browser scrolls to the element.\n\n\n    var scrollTop = elem.scrollTop;\n    elem.value = newText;\n    prevValue = elem.value; // Not done on one line so the browser can do newline conversion.\n\n    if (elem.scrollTop !== scrollTop) {\n      elem.scrollTop = scrollTop;\n    } // Setting the selection moves the cursor. We'll just have to let your\n    // cursor drift if the element isn't active, though usually users don't\n    // care.\n\n\n    if (newSelection && window.document.activeElement === elem) {\n      elem.selectionStart = newSelection[0];\n      elem.selectionEnd = newSelection[1];\n    }\n  };\n\n  replaceText(doc.data); // *** remote -> local changes\n\n  doc.on('op', function (op, localContext) {\n    if (localContext === true) {\n      return;\n    }\n\n    var prev = elem.value;\n    var newDoc = []; // Loop through the ops object.\n\n    for (var i = 0; i < op.length; i++) {\n      var component = op[i]; // Classifies the different components of the op.\n\n      switch (typeof component) {\n        // If it is a number, make it the index.\n        case 'number':\n          // fields.pos = component;\n          newDoc.push(prev.slice(0, component));\n          prev = prev.slice(component);\n          break;\n        // If it is a string, we know to insert it into the temp variable.\n\n        case 'string':\n          // fields.insertStr = component;\n          // onInsert(fields.pos, fields.insertStr);\n          newDoc.push(component);\n          break;\n        // If it is an object, we know it's a delete command.\n\n        case 'object':\n          prev = prev.slice(component.d); // fields.delNum = component.d;\n          // onRemove(fields.pos, fields.delNum);\n\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return setTimeout(function () {\n      replaceText(newDoc.join('') + prev);\n    }, 0);\n  }); // *** local -> remote changes\n  // This function generates operations from the changed content in the textarea.\n\n  var genOp = function genOp() {\n    // In a timeout so the browser has time to propagate the event's changes to the DOM.\n    setTimeout(function () {\n      if (elem.value !== prevValue) {\n        prevValue = elem.value;\n        applyChange(doc, doc.data, elem.value);\n      }\n    }, 0);\n  };\n\n  var eventNames = ['textInput', 'keydown', 'keyup', 'select', 'cut', 'paste'];\n\n  for (var i = 0; i < eventNames.length; i++) {\n    var e = eventNames[i];\n\n    if (elem.addEventListener) {\n      elem.addEventListener(e, genOp, false);\n    } else {\n      elem.attachEvent('on' + e, genOp);\n    }\n  }\n\n  doc.detach = function () {\n    for (var _i = 0; _i < eventNames.length; _i++) {\n      var _e = eventNames[_i];\n\n      if (elem.removeEventListener) {\n        elem.removeEventListener(_e, genOp, false);\n      } else {\n        elem.detachEvent('on' + _e, genOp);\n      }\n    }\n  };\n\n  return doc;\n};","map":null,"metadata":{},"sourceType":"module"}