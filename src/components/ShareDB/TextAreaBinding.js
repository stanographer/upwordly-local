/* This contains the textarea binding for ShareDB. This binding is really
 * simple, and a bit slow on big texuments (Its O(N). However, it requires no
 * changes to the DOM and no heavy libraries like ace. It works for any kind of
 * text input field.
 *
 * You probably want to use this binding for small fields on forms and such.
 * For code editors or rich text editors or whatever, I recommend something
 * heavier.
 */

/* applyChange creates the edits to convert oldVal -> newVal.
 *
 * This function should be called every time the text element is changed.
 * Because changes are always localised, the diffing is quite easy. We simply
 * scan in from the start and scan in from the end to isolate the edited range,
 * then delete everything that was removed & add everything that was added.
 * This wouldn't work for complex changes, but this function should be called
 * on keystroke - so the edits will mostly just be single character changes.
 * Sometimes they'll paste text over other text, but even then the diff
 * generated by this algorithm is correct.
 *
 * This algorithm is O(N). I suspect you could speed it up somehow using regular expressions.
 */

// Attach a textarea to a document's editing providers.
// The providers is optional, and will be created from the document if its not
// specified.
export const attachTextarea = (elem, doc) => {
  elem.value = doc.data;

  // The current value of the element's text is stored so we can quickly check
  // if its been changed in the event handlers. This is mostly for browsers on
  // windows, where the content contains \r\n newlines. applyChange() is only
  // called after the \r\n newlines are converted, and that check is quite
  // slow. So we also cache the string before conversion so we can do a quick
  // check in case the conversion isn't needed.

  let prevValue;
  let newSelection = [];

  // Enables tab input inside textarea.
  elem.onkeydown = e => {
    // Tab was pressed
    if (e.key === 'Tab') {
      // Prevent normal behavior of switching element focus.
      e.preventDefault();

      // Get caret position/selection
      const val = elem.value;

      const start = elem.selectionStart;

      const end = elem.selectionEnd;

      // Set textarea value to: text before caret + tab + text after caret
      elem.value = `${val.substring(0, start)}\t${val.substring(end)}`;

      // Put caret at right position again
      elem.selectionStart = elem.selectionEnd = start + 1;

      // Prevent the focus lose
      return false;
    }
  };

  const applyChange = (doc, oldVal, newVal) => {
    // Strings are immutable and have reference equality. I think this tests is O(1), so its worth doing.
    if (oldVal === newVal) {
      return;
    }

    let commonStart = 0;

    while (oldVal.charAt(commonStart) === newVal.charAt(commonStart)) {
      commonStart += 1;
    }

    let commonEnd = 0;

    while (
      oldVal.charAt(oldVal.length - 1 - commonEnd) ===
        newVal.charAt(newVal.length - 1 - commonEnd) &&
      commonEnd + commonStart < oldVal.length &&
      commonEnd + commonStart < newVal.length
    ) {
      commonEnd += 1;
    }

    if (oldVal.length !== commonStart + commonEnd) {
      const op = [
        commonStart,
        '',
        { d: oldVal.length - commonStart - commonEnd },
      ];
      doc.submitOp(op);
    }

    if (newVal.length !== commonStart + commonEnd) {
      doc.submitOp([
        commonStart,
        newVal.slice(commonStart, newVal.length - commonEnd),
      ]);
    }
  };

  /* Replace the content of the text area with newText, and transform the
   current cursor by the specified function. */

  const replaceText = function(newText, transformCursor) {
    if (transformCursor) {
      newSelection = [
        transformCursor(elem.selectionStart),
        transformCursor(elem.selectionEnd),
      ];
    }

    // Fixate the window's scroll while we set the element's value. Otherwise
    // the browser scrolls to the element.
    const scrollTop = elem.scrollTop;
    elem.value = newText;
    prevValue = elem.value; // Not done on one line so the browser can do newline conversion.
    if (elem.scrollTop !== scrollTop) {
      elem.scrollTop = scrollTop;
    }

    // Setting the selection moves the cursor. We'll just have to let your
    // cursor drift if the element isn't active, though usually users don't
    // care.
    if (newSelection && window.document.activeElement === elem) {
      elem.selectionStart = newSelection[0];
      elem.selectionEnd = newSelection[1];
    }
  };

  setTimeout(() => replaceText(doc.data), 0);

  // *** remote -> local changes

  doc.on('op', (op, localContext) => {
    if (localContext === true) {
      return;
    }

    let prev = elem.value;
    const newDoc = [];

    // Loop through the ops object.
    for (let i = 0; i < op.length; i += 1) {
      const component = op[i];

      // Classifies the different components of the op.
      switch (typeof component) {
        // If it is a number, make it the index.
        case 'number':
          newDoc.push(prev.slice(0, component));
          prev = prev.slice(component);
          break;

        // If it is a string, we know to insert it into the temp variable.
        case 'string':
          newDoc.push(component);
          break;

        // If it is an object, we know it's a delete command.
        case 'object':
          prev = prev.slice(component.d);
          break;
        default:
          break;
      }
    }

    return setTimeout(() => {
      replaceText(newDoc.join('') + prev);
    }, 0);
  });

  // *** local -> remote changes

  // This function generates operations from the changed content in the textarea.
  const genOp = () => {
    // In a timeout so the browser has time to propagate the event's changes to the DOM.
    setTimeout(() => {
      if (elem.value !== prevValue) {
        prevValue = elem.value;
        applyChange(doc, doc.data, elem.value);
      }
    }, 0);
  };

  const eventNames = [
    'textInput',
    'keydown',
    'keyup',
    'select',
    'cut',
    'paste',
  ];

  for (let i = 0; i < eventNames.length; i += 1) {
    const e = eventNames[i];

    if (elem.addEventListener) {
      elem.addEventListener(e, genOp, false);
    } else {
      elem.attachEvent(`on${e}`, genOp);
    }
  }

  doc.detach = () => {
    for (let i = 0; i < eventNames.length; i += 1) {
      const e = eventNames[i];

      if (elem.removeEventListener) {
        elem.removeEventListener(e, genOp, false);
      } else {
        elem.detachEvent(`on${e}`, genOp);
      }
    }
  };

  return doc;
};
